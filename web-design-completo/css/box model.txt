Ruby em 30 minutos

puts 4 * 10
puts 5 - 12
puts 30 / 4

puts (coloque) algo na tela;

"Victor".reverse => rotciV => reverte a string (aplicável apenas para strings)

"victor".length => 6 => Sim. Length também é um 'método' de contagem de caracteres

/* Ei, Sumário #1 Pronto
Vamos revisar o que nós aprendemos neste primeiro minuto.

O editor
Digitando o código no editor e clicando em run, o resultado do seu código é exibido na tela de saída. (Quase) todos os códigos fornecem uma resposta.

Numeros e strings
Números e strings são os objetos matemáticos e de texto do Ruby.

Métodos
Você usou métodos em inglês como reverse e length. E usou métodos simbólicos como o método de multiplicação: *. Métodos significam ações!

Esta é a essência do seu aprendizado. Pegando coisas simples, brincando com elas e então tornando-as coisas novas. Já se sente confortável? Tenho certeza que você está.*/

Mas e se for um número?

40.to_s.reverse => 04 => transforma o número em string, em seguida reverte.

Convertendo dados
to_s converte coisas para strings
to_i converte coisas para integers (números)
to_a converte coisas para arrays

Arrays
[12, 47, 35, 28]

*** [12, 47, 35, 28] => Armazenado na váriavel bilhete***

[12, 47, 35].max => 47 => Retorna o maior número contido na array.

.sort! => Ordena os itens dentro da Array/Variável.

.first => retorna o primeiro item da array.

.last => retorna o último item da array.

puts bilhete[0] = 12
puts bilhete[1] = 47
puts bilhete[2] = 35

[número] alvo dentro da array, similar a bracket notation do JavaScript

Todo array inicia em 0

/* Sumário #2 Está Sobre Nós
Agora, vejamos como nosso segundo minuto foi:

Erros
Se você tentar inverter um número, o Ruby irá lhe dizer um erro.

Arrays
Arrays são listas para guardar coisas em alguma ordem. Nós também aprendemos como criar arrays e recuperar itens de arrays.

Variáveis
Variáveis salvam a coisa e dão um nome pra ela. Você usou o símbolo de igual para isso. Por exemplo: bilhete = [14, 37, 18]. */

Minha manga voou da minha mão
E minha manga se foi para a lua.
Mas quando eu vejo isso na televisão,
Colocando nossa bandeira no cometa Halley,
Mais ainda eu quero come-la.

poema.gsub("torrada", "manga") => Substitui o valor "torrada" por "manga".

.gsub => abreviação para substituição global

O método gsub precisa de dois argumentos, que nós passamos para o gsub ao incluir duas strings entre parênteses. Argumentos falam para o método exatamente o que fazer

Minha manga voou da minha mão
E minha manga se foi para a lua.
Mas quando eu vejo isso na televisão,
Colocando nossa bandeira no cometa Halley,
Mais ainda eu quero come-la.

poema.reverse = reverte todo o poema:

.al-emoc oreuq ue adnia siaM
,yellaH atemoc on ariednab asson odnacoloC
,oãsivelet an ossi ojev ue odnauq saM
.aul a arap iof es adarrot ahnim E
oãm ahnim ad uoov adarrot ahniM

poema.lines.reverse = reverte a ordem dos argumentos dentro da array poema:

["Mais ainda eu quero come-la.\n", 
"Colocando nossa bandeira no cometa Halley,\n", 
"Mas quando eu vejo isso na televisão,\n", 
"E minha torrada se foi para a lua.\n", 
"Minha torrada voou da minha mão\n"]

\n => quebra de linha
.lines decide a forma como a string será dividida e converte isso em um array.

puts poema.lines.reverse.join = 
Mais ainda eu quero come-la.
Colocando nossa bandeira no cometa Halley,
Mas quando eu vejo isso na televisão,
E minha torrada se foi para a lua.
Minha torrada voou da minha mão

O método join pega este array de linhas e junta todas elas em uma string.

.join => de juntar;

Combinando métodos desta forma é chamado de encadeamento de métodos

poema.downcase => letras minúsculas.
poema.swapcase => letras maiúsculas.

Documentação da classe string => http://ruby-doc.org/core/classes/String.html

/* De todos os sumários #3 está aqui agora
Exclamações
Métodos podem ter exclamações (e também interrogações) em seus nomes. Isto são apenas formas de explicar melhor qual é sua função. Nada de mais.

Manipulação de string
Buscar e alterar strings

Encadeamento
Encadeamento de métodos permite que você faça muito mais. Quebrar um poema, inverte-lo, remonta-lo: poema.lines.reverse.join

A esta altura, talvez você queira brincar com o poema um pouco mais. A lista completa de todos os métodos de String está aqui

Vá em frente e tente um pouco, coisas como: poema.downcase ou poema.swapcase*/

livros = {} => Você criou um hash vazio.

Um hash vazio. Um hash é como um array, porém cada um dos seus elementos tem um nome.

livros["Até o Fim"]  = :lixo => Classifica o livro como lixo
livros["Cores Vivas"] = :mediocre => Classifica o livro como mediocre
 
puts livros => exibe o hash com os livros definidos como elementos de uma array

{"O Arco-Íris da Gravidade"=>"esplendido", "Até o Fim"=>"lixo", "Cores Vivas"=>"mediocre"}

puts livros.length = 3 => exibe a quantidade de itens em um array/hash

puts livros["O Arco-Íris da Gravidade"] => acessa a propriedade dentro do hash e exibe sua carcterística.

Diferente do array o hash é acessado pelo nome["O Arco-Íris da Gravidade"] ao invés do número[0].

Em suas análises, o título do livro é a key, e a classificação é o value.

livros.keys => Retorna todas as keys de um Hash.
livros.values => Retorna todos os valores de um Hash.

5.times { print "Odelay! " } => Repete 5 vezes a mensagem Odelay!

.times => repete um código uma quantidade de vezes.
print => exibe uma mensagem/string.

9.times { |vez|
  puts vez
}

=> envia o valor para a variável |vez|

/*Agora Desembarcando no Sumário #4
Esta última lição é um pouco mais longa. Você provavelmente usou três minutos aprendendo sobre:

Hashes
O pequeno dicionário com páginas chaves: {}

Símbolos
Pequenos, eficientes palavras de código com dois pontos, como: :esplendido

Blocos
Trechos de código que podem ser usados com muitos métodos do Ruby. Aqui o código usado para construir o scorecard: livros.values.each { |classificacao| classificacoes[classificacao] += 1 } */

Parênteses
Atualmente, na maior parte das vezes o Ruby não se importa se você omitir os parenteses

puts "Olá!" => Olá!
puts("Olá!") => Olá!


Métodos
Por que isso é uma boa idéia? Dois motivos:
Para fazer o seu programa ficar menor e para tornar o seu código mais fácil de ler.

Então, como definimos um método? Assim:

def domar( numero_de_megeras )
end

Você iniciou com def, seguido do nome do método. E a lista de argumentos que este método precisará. Tudo o que temos que fazer é preenche-lo com Ruby e finaliza-lo com a palavra end.

def domar( numero_de_megeras )
  numero_de_megeras.times {
    puts "Megera domada"
  }
end
domar(2)

Resposta
Megera domada
Megera domada


def domar( numero_de_megeras )
  numero_de_megeras.times {
    puts "Megera domada"
  }
  return numero_de_megeras
end

puts domar(2)

Resposta
Megera domada
Megera domada
2

Dica: a palavra pode ser omitida nesse caso e ainda assim termos o return da função

/*Olá, Quem Está Ai? E Sumário #5 Segura o Chapéu!
Muito bem, muito bem, muito bem, muito bem!

Verdadeiramente, verdadeiramente, verdadeiramente, verdadeiramente, verdadeirameeeeeente!

Aqui estão os últimos minutos da nosa vida revisados:

Métodos
Métodos podem ser definidos com def e têm um nome. Métodos tornam os seus programas mais curtos e fáceis de ler.

Parâmetros
Métodos podem receber parâmetros.

Retornar valores
Métodos (quase) sempre retornam valores.

Agora
(Ser) ou não (ser) não é mais uma dúvida para você. Você está pronto para um pouco mais de Shakespare? */

Formatos
Existem muitos outros formatos, com nomes estranhos, disponíveis e utilizados na web. Como: html, xml e json. Sim, mesmo este website tem um monte desses.

Eu preparei um método para você que lhe permitirá buscar, da internet, uma lista com os trabalhos concluídos de William Shakespeare.

get_skakey => {"William Shakespeare"=>{"1"=>{"title"=>"The Two Gentlemen of Verona", "finished"=>1591}, "2"=>{"title"=>"The Taming of the Shrew", "finished"=>1591}, "3"=>{"title"=>"Henry VI, Part 2", "finished"=>1591}, "4"=>{"title"=>"Henry VI, Part 3", "finished"=>1591}, "5"=>{"title"=>"Henry VI, Part 1", "finished"=>1592}, "6"=>{"title"=>"Titus Andronicus", "finished"=>1592}, "7"=>{"title"=>"Richard III", "finished"=>1593}, "8"=>{"title"=>"Edward III", "finished"=>1593}, "9"=>{"title"=>"The Comedy of Errors", "finished"=>1594}, "10"=>{"title"=>"Love's Labour's Lost", "finished"=>1595}, "11"=>{"title"=>"Love's Labour's Won", "finished"=>1596}, "12"=>{"title"=>"Richard II", "finished"=>1595}, "13"=>{"title"=>"Romeo and Juliet", "finished"=>1595}, "14"=>{"title"=>"A Midsummer Night's Dream", "finished"=>1595}, "15"=>{"title"=>"King John", "finished"=>1596}, "16"=>{"title"=>"The Merchant of Venice", "finished"=>1597}, "17"=>{"title"=>"Henry IV, Part 1", "finished"=>1597}, "18"=>{"title"=>"The Merry Wives of Windsor", "finished"=>1597}, "19"=>{"title"=>"Henry IV, Part 2", "finished"=>1598}, "20"=>{"title"=>"Much Ado About Nothing", "finished"=>1599}, "21"=>{"title"=>"Henry V", "finished"=>1599}, "22"=>{"title"=>"Julius Caesar", "finished"=>1599}, "23"=>{"title"=>"As You Like It", "finished"=>1600}, "24"=>{"title"=>"Hamlet", "finished"=>1601}, "25"=>{"title"=>"Twelfth Night", "finished"=>1601}, "26"=>{"title"=>"Troilus and Cressida", "finished"=>1602}, "27"=>{"title"=>"Sir Thomas More", "finished"=>1604}, "28"=>{"title"=>"Measure for Measure", "finished"=>1604}, "29"=>{"title"=>"Othello", "finished"=>1604}, "30"=>{"title"=>"All's Well That Ends Well", "finished"=>1605}, "31"=>{"title"=>"King Lear", "finished"=>1606}, "32"=>{"title"=>"Timon of Athens", "finished"=>1606}, "33"=>{"title"=>"Macbeth", "finished"=>1606}, "34"=>{"title"=>"Antony and Cleopatra", "finished"=>1606}, "35"=>{"title"=>"Pericles, Prince of Tyre", "finished"=>1608}, "36"=>{"title"=>"Coriolanus", "finished"=>1608}, "37"=>{"title"=>"The Winter's Tale", "finished"=>1611}, "38"=>{"title"=>"Cymbeline", "finished"=>1610}, "39"=>{"title"=>"The Tempest", "finished"=>1611}, "40"=>{"title"=>"Cardenio", "finished"=>1613}, "41"=>{"title"=>"Henry VIII", "finished"=>1613}, "42"=>{"title"=>"The Two Noble Kinsmen", "finished"=>1614}}}

Iterando os itens com .each

s = get_shakey

s["William Shakespeare"].each { |key, val|
  puts val["title"]
}

=>

The Two Gentlemen of Verona
The Taming of the Shrew
Henry VI, Part 2
Henry VI, Part 3
Henry VI, Part 1
Titus Andronicus
Richard III
Edward III
The Comedy of Errors
Love's Labour's Lost
Love's Labour's Won
Richard II
Romeo and Juliet
A Midsummer Night's Dream
King John
The Merchant of Venice
Henry IV, Part 1
The Merry Wives of Windsor
Henry IV, Part 2
Much Ado About Nothing
Henry V
Julius Caesar
As You Like It
Hamlet
Twelfth Night
Troilus and Cressida
Sir Thomas More
Measure for Measure
Othello
All's Well That Ends Well
King Lear
Timon of Athens
Macbeth
Antony and Cleopatra
Pericles, Prince of Tyre
Coriolanus
The Winter's Tale
Cymbeline
The Tempest
Cardenio
Henry VIII
The Two Noble Kinsmen

O Ruby nos permite selecionar (select) valores do hash. O método select usa um bloco para nos deixar definir o que selecionar, e retorna o que for encontrado.

def count_plays(year)
  s = get_shakey

  s["William Shakespeare"]
    .select { |k, v|
      v["finished"] == year
    }.each { |key, val|
      puts val["title"]
    }.count
end

puts count_plays(1591)

=>

The Two Gentlemen of Verona
The Taming of the Shrew
Henry VI, Part 2
Henry VI, Part 3
4

Ok, nós pegamos alguns dados da internet, nós selecionamos o que nós queriamos e imprimimos na tela. O que falta melhorar? Nós poderiamos ter impresso os resultados de forma um pouco mais bonita. Como adicionar o ano e alinhar títulos e anos.

def print_plays(year_from, year_to)
  get_shakey["William Shakespeare"]
    .select { |k, v|
      year_from <= v["finished"] &&
      year_to   >= v["finished"]
    }.each { |k, v|
      puts "#{k.ljust(5)} #{v["title"].ljust(30)} #{v["finished"]}"
    }
end
print_plays(1600, 1605)

=>

23    As You Like It                 1600
24    Hamlet                         1601
25    Twelfth Night                  1601
26    Troilus and Cressida           1602
27    Sir Thomas More                1604
28    Measure for Measure            1604
29    Othello                        1604
30    All's Well That Ends Well      1605


.ljust = tamanho do campo do texto e alinhado à esquerda


IF e ELSE

If é um método que requer um parâmetro. Este parâmetro pode ser qualquer expressão que você queira testar. A saída da expressão, no entanto, deve ser true (verdadeiro) ou false (falso). Aqui estão um monte de expressões e suas saídas:

if 1 < 2
  puts "É verdade: 1 é menor que 2"
end

=>

É verdade: 1 é menor que 2

Dica: Este == significa é igual a. Um único sinal de igual que nós vimos antes significa atribua o valor a variável.

a = 0

if a == 100
  puts "A expressão é verdadeira, mas agora a é: #{a}"
else
  puts "#{a} não é igual a 100"
end

=>

0 não é igual a 100

Mais expressões de controle
http://ruby-doc.org/core-2.6.3/doc/syntax/control_expressions_rdoc.html

Desafio.mimFome

def fome?(hora_do_dia)
  puts "Mim fome"
  true
end

def comer_um(o_que)
  puts "Mim comer #{o_que}\n"
end

comer_um 'maçã' if fome?(14)

comer_um 'maçã' if fome?(10)

*** Agora, veja se você consegue alterar o método fome? para exibir Mim sem fome e retornar falso quando a hora for menor que 12. ***

def fome?(hora_do_dia)
if hora_do_dia > 12
puts "Mim fome"
  true
else
puts "Mim sem fome"
  false
end
end

def comer_um(o_que)
puts "Mim comer #{o_que}\n"
end

comer_um 'maçã' if fome?(14)

comer_um 'maçã' if fome?(10)


/* Sumário #6 Que Significa Que Você Foi Bem Longe
Você é um clérigo Ruby level 6. Quero dizer, que grande trabalho você fez. Vamos revisar:

Dados
Você carregou alguns dados da internet,

Iterando
Você iterou todos os elementos de um hash e você encadeou alguns outros métodos.

Imprimindo Bonito
E como se isso não fosse o bastante, você formatou e imprimiu alguns valores de uma forma que é fácil para humanos ler. De fato, você fez um programa real!

IF
Você aprendeu a tomar o controle dos seus programasa com declarações de if e else.

Então
O que é possível fazer em seguida? O que é possível que você ainda tenha que aprender agora? Ha! Esta é a melhor parte. Você Ha, this is the best part. Você percorreu um caminho tão grande que agora vamos revelar as classes. Apenas mais duas lições curtas, e acabou.*/

Class

BlurbalizerTM
Você acabou de ter uma brilhante idéia para um novo aplicativo. Ele será a nova plataforma de mensagens instantâneas. Você quer um aplicativo onde as pessoas possam enviar curtas mensagens para as outras. Você chama isso de BlurbsTM. Os BlurbsTM permite o tamanho máximo de apenas 40 caracteres. Vamos fazer algumas configurações de humor também.

Onde começar
Bem, você deve armazenar seus BlurbsTM em um arquivo json, certo? Mas como você poderia manter o rastreamento do conteúdo e da hora em que foi postado? E quando o arquivo foi carregado, como isso ficaria no Ruby? Isto deveria ser um Hash? Ou um Array? Ou um Array de Arrays? Ou algo diferente?

Dicas classes inciam com letra Maiúscula

Criando uma classe

class Blurb
end

Você abriu a nova BlurbTM class. Do que a entrada do seu blog é feita? De conteúdo, claro. Também, a hora em que o BlurbTM foi postado. E o humor.

class Blurb
  attr_accessor :conteudo, :hora, :humor
end

attr_accessor = > Existem vários métodos de <b>att</b>ributos como esse que adicionam pequenas configurações as classes. Esses atributos são apenas variáveis amarradas a classe.

blurb1 = Blurb.new = cria um novo objeto dentro da classe Blurb
puts blurb1
blurb1.conteudo = "Hoje, Mount Hood foi roubado!"

continuando

blurb1.tempo = Time.now = Colaca a data de hoje
blurb1.humor = :doente = Define o humor

puts blurb1

Apressando as coisas

class Blurb #Cria a classe Blurb
  attr_accessor :conteudo, :tempo, :humor #Amarra Variáveis a classe

  def initialize(humor, conteudo="") #initialize?? 
    @tempo    = Time.now #seleciona o tempo atual
    @conteudo = conteudo[0..39] #define o tamanho máximo da String
    @humor    = humor
  end
end

Blurb.new.tempo


Crie outro BlurbTM
Quando um novo BlurbTM é criado, o método initialize é usado para verificar por algum argumento para o new.

Uh, nós precisamos de dois argumentos:

Blurb2 = Blurb.new :confuso, "Eu não posso acreditar que Mt. Hood foi roubado!"

/*Uma Girafa Não Roubou o Sumário #7
Aha! Você está aqui. E inteiro. Nós vamos continuar a fazer o seu app real, mas enquanto isso, vamos revisar ok?

Classes
Tudo em Ruby é algum tipo de objeto. Classes explicam objetos, como um certo tipo de objeto funciona. Por exemplo, você criou alguns objetos BlurbTM e esses objetos são explicados na classe Blurb. Em outras palavras: você os chama de objetos Blurb. Você pode usar classes (meio que) para modelar objetos da vida real

Acessores
Acessores são variáveis atreladas a um objeto que podem ser usadas fora do objeto. (blurb2.tempo = Time.now)

Variáveis de objeto
Variáveis de objeto são as mesmas variáveis que você está utilizando com os acessores, porém, dentro do objeto. (@tempo = Time.now)*/

Seu próprio gramado
Ok, vamos embrulhar as coisas, garoto. Este é o último capítulo da EMOCIONANTE e épica história do Try Ruby! Agora que você já sentiu o gostinho de como tudo funciona, como nós vamos usar isso em volta da casa e no freezer da sua mercearia? Você é uma grande pessoa (uma das minhas favoritas), mas você precisa de orientação.

Vamos finalizar seu app

class Blurbalizer
  def initialize(titulo)
    @titulo  = titulo
    @blurbs = [] # Um array fresquinho e limpo
                 # para armazenar os Blurbs
  end

  def adicionar_um_blurb(humor, conteudo)
    # O << significa adicionar ao array
    @blurbs << Blurb.new(humor, conteudo)
  end

  def exibir_timeline
    puts "Blurbify: #{@titulo} tem #{@blurbs.count} Blurbs"

    @blurbs.sort_by { |t|
      t.tempo
    }.reverse.each { |t|
      puts "#{t.conteudo.ljust(40)} #{t.tempo}"
    }
  end
end

meuApp = Blurbalizer.new "O Grande Blurb"

Adicionando um Blurb e Listando-os

meuApp.adicionar_um_blurb :temperamental, "Adicione um Blurb aqui"

meuApp.exibir_timeline

Isto é tudo sobre combinar

class Blurb
  attr_accessor :conteudo, :tempo, :humor

  def initialize(humor, conteudo="")
    @tempo    = Time.now
    @conteudo = conteudo[0..39]
    @humor    = humor
  end

  def modificar
    if    @humor == :triste
      return ":-("
    elsif @mood == :feliz
      return ":-)"
    # E outros humores aqui
    end

    # O humor padrão
    ":-|"
  end
end

class Blurbalizer
  def initialize(titulo)
    @titulo  = titulo
    @blurbs = []
  end

  def adicionar_um_blurb(humor, conteudo)
    @blurbs << Blurb.new(humor, conteudo)
  end

  def exibir_timeline
    puts "Blurbalizer: #{@titulo} tem #{@blurbs.count} Blurbs"

    @blurbs.sort_by { |t|
      t.tempo
    }.reverse.each { |t|
      puts "#{t.conteudo.ljust(40)} #{t.tempo}"
    }
  end
end


meuApp.adicionar_um_blurb :triste, "Adicione um Blurb aqui"
meuApp.adicionar_um_blurb :temperamental, "Adicione um Blurb aqui"

meuApp.exibir_timeline















/*Sumário #8, O Sumário do Ei-Relaxa-Você-Foi-Bem
Esta última sessão é um momento para relaxar, para lhe dar aluma direção sobre como você pode usar o Ruby.

Se você gostou, você pode continuar com o TryRuby Playground ou baixar e instalar o Ruby: ruby-lang.org

Uma vez que você tenha o Ruby instalado, você poderá criar um arquivo, digamos meu_primeiro_programa.rb, usando um editor de texto, escrever algum código Ruby e então roda-lo. Para roda-lo abra o prompt de comando e digite:

ruby meu_primeiro_programa.rb
Existem várias ferramentas (gratuitas) de desenvolvimento disponíveis para combinar um editor, explorador de arquivos e um ruby-runner.

Comemore
Você realmente merece comer um doblo de camada dupla, com duplo sorvete, enquanto um cara toca uma daquelas guitarras que na verdade são guitarras duplas. Quero dizer, você terminou. Você realmente terminou! Não há duvidas sobre isso, você é um sangue-vermelho espertão certificado!*/


